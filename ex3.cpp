#include <stdio.h>
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>

// формат ввода: данные, ключ

// 19 a0 9a e9
// 3d f4 c6 f8 
// e3 e2 8d 48
// be 2b 2a 08
//
// a0 88 23 2a
// fa 53 a3 6c
// fe 2c 39 76
// 17 b1 39 05

bool copyMatrix4_4(const int sourceMatrix[4][4] , int outputMatrix[4][4]){
    for (int i=0; i<16; i++){
        outputMatrix[i/4][i%4] = sourceMatrix[i/4][i%4];
    }
}

void multiply(int mat1[][4], int mat2[][4], int res[][4]){
    int i, j, k;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < 4; j++) {
            res[i][j] = 0;
            for (k = 0; k < 4; k++)
                res[i][j] ^= (mat1[i][k] * mat2[k][j]) %283;  //283   27
            res[i][j] = res[i][j]; //%17
        }

    }
}



class Rijngael{
    int state[4][4];
    int key[4][4];
    //int rounds = 1;
    int s[256] =   {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
        ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
        ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
        ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
        ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
        ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
        ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
        ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
        ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
        ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
        ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
        ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
        ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
        ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
        ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
        ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};
    

    // int mixColumsMatrix [4][4] = {{2,3,1,1},
    //                               {1,2,3,1},
    //                               {1,1,2,3},
    //                               {3,1,1,2}}; 

    
    void subBytes(){
        for (int i=0; i<16; i++){
            state[i/4][i%4] = s[ state[i/4][i%4] ];
        }
    };
    void shiftRows(){
        for (int row=1; row < 4; row++){
            std::rotate(state[row], state[row]+row, state[row]+4);
        }
    };

    int multiply_by_2(const int v){
        int s = v << 1;
        if (v & 0x80){
            s &= 0xff;
            s = s ^ 0x1b;
        }
        return s;
    }

    int multiply_by_3(int v){
        return multiply_by_2(v) ^ v;
    }


    void mixColums(){
        int tmpMatrix[4][4];
        for (int colum=0; colum<4; colum++){
            for (int shift=0;shift<4;shift++){
                tmpMatrix[shift][colum] = multiply_by_2(state[shift][colum]) ^ multiply_by_3(state[(shift+1)%4][colum]) ^ state[(shift+2)%4][colum] ^ state[(shift+3)%4][colum];
            }
        }
        
        copyMatrix4_4(tmpMatrix, state);
    }
    void addRoundKey(){
        int tmp;
        for (int i=0; i<16; i++){
            tmp = state[i/4][i%4] ^ key[i/4][i%4];
            state[i/4][i%4] =  tmp;
        }
    };

    void printRoundResult(){
        for (int i = 0; i < 4; i++){
            for (int j = 0; j < 4; j++)
            {
                printf("%02x ", state[i][j]);
            }
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }

public:

    Rijngael(const int (&data_)[4][4], const int (&key_)[4][4]) { //, int rounds_
        copyMatrix4_4(data_, state);
        copyMatrix4_4(key_, key);
    }

    void encode(){
        subBytes();
        std::cout << "result of subBytes " << std::endl;
        printRoundResult();

        shiftRows();
        std::cout << "result of shiftRows " << std::endl;
        printRoundResult();
        
        mixColums();
        std::cout << "result of mixColums " << std::endl;
        printRoundResult();

        addRoundKey();
        std::cout << "result of addRoundKey " << std::endl;
        printRoundResult();
     
    };

};



int main(){
    int data[4][4];
    int key[4][4];
    for (int n=0; n<16; n++){
        scanf("%x", &data[n/4][n%4]);
    }

    for (int n=0; n<16; n++){
        scanf("%x", &key[n/4][n%4]);
    }

    Rijngael *encoder = new Rijngael(data, key);

    encoder->encode();
    
    return 0;
}